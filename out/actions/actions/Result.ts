
import BaseType, { FixedChar3, uint, VarChar } from "./../../Base";
import Amendment from "./../../actions/types/Amendment";

/**
 * ### Result ###
 * Once a vote has been completed the results are published. After the result is posted, it is up to the administration to send a contract/asset amendement if appropriate.
 */
class Result extends BaseType {

  constructor() {
    super();
    super.requiredFieldNames = [  ];
    super.fieldNames = [ "AssetType", "AssetCode", "ProposedAmendments", "VoteTxId", "OptionTally", "Result", "Timestamp" ];
  }

  public validate() {
    super.validateAllFields();
  }

  
  private _AssetType: FixedChar3;
  /**
   * # Asset Type #
   * Three letter character that specifies the asset type.
   */
  public set AssetType(val: string) {
    this._AssetType = new FixedChar3(val);
    this._AssetType.validate();
  }
  public get AssetType() : string {
    return this._AssetType.value;
  }

  private _AssetCode: AssetCode;
  /**
   * # Asset Code #
   * A unique code that is used to identify the asset. It is generated by hashing the contract public key hash and the asset index. SHA256(contract PKH + asset index)
   */
  public set AssetCode(val: AssetCode) {
    this._AssetCode = val;
    this._AssetCode.validate();
  }
  public get AssetCode() : AssetCode {
    // TODO: implement this unsupported scenario
  }

  private _ProposedAmendments: Amendment[];
  /**
   * # Proposed Amendments #
   * Each element contains details of which fields to modify, or delete. Because the number of fields in a Contract and Asset is dynamic due to some fields being able to be repeated, the index value of the field needs to be calculated against the Contract or Asset the changes are to apply to. In the event of a Vote being created from this Initiative, the changes will be applied to the version of the Contract or Asset at that time.
   */
  public set ProposedAmendments(val: Amendment[]) {
    this._ProposedAmendments = val;
    this._ProposedAmendments.forEach(i => i.validate());
  }
  public get ProposedAmendments() : Amendment[] {
    return this._ProposedAmendments;
  }

  private _VoteTxId: TxId;
  /**
   * # Vote Tx ID #
   * Link to the Vote Action txn.
   */
  public set VoteTxId(val: TxId) {
    this._VoteTxId = val;
    this._VoteTxId.validate();
  }
  public get VoteTxId() : TxId {
    // TODO: implement this unsupported scenario
  }

  private _OptionTally: UInt64[];
  /**
   * # Option Tally #
   * List of number of valid votes counted for each vote option. Length is encoded like a regular list object, but must match the length of VoteOptions from the Proposal action.
   */
  public set OptionTally(val: number[]) {
    this._OptionTally = val.map(v => new uint(v));
    this._OptionTally.forEach(i => i.validate());
  }
  public get OptionTally() : number[] {
    return this._OptionTally.map(i => i.value);
  }

  private _Result: VarChar;
  /**
   * # Result #
   * Length 1-255 bytes. 0 is not valid. The Option with the most votes. In the event of a draw for 1st place, all winning options are listed.
   */
  public set Result(val: string) {
    this._Result = new VarChar(val);
    this._Result.validate();
  }
  public get Result() : string {
    return this._Result.value;
  }

  private _Timestamp: Timestamp;
  /**
   * # Timestamp #
   * Timestamp in nanoseconds of when the smart contract created the action.
   */
  public set Timestamp(val: Timestamp) {
    this._Timestamp = val;
    this._Timestamp.validate();
  }
  public get Timestamp() : Timestamp {
    // TODO: implement this unsupported scenario
  }
}

export default Result;