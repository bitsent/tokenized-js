
import BaseType, { FixedChar3, AssetCode, TxId, UInt64, VarChar, Timestamp } from "./../../Base";
import Amendment from "./../../actions/types/Amendment";

/**
 * # Result
 * Once a vote has been completed the results are published. After the result is posted, it is up to the administration to send a contract/asset amendement if appropriate.
 */
class Result extends BaseType {

  constructor() {
    super();
    super.requiredFieldNames = [  ];
    super.fieldNames = [ "AssetType", "AssetCode", "ProposedAmendments", "VoteTxId", "OptionTally", "Result", "Timestamp" ];
  }

  public validate() {
    super.validateAllFields();
  }

  private _AssetType: FixedChar3;
  private _AssetCode: AssetCode;
  private _ProposedAmendments: Amendment[];
  private _VoteTxId: TxId;
  private _OptionTally: UInt64[];
  private _Result: VarChar;
  private _Timestamp: Timestamp;

  
  /**
   * ### Asset Type 
   * Three letter character that specifies the asset type.
   */
  public set AssetType(val: string) {
    this._AssetType = new FixedChar3(val);
    this._AssetType.validate();
  }
  /**
   * ### Asset Type 
   * Three letter character that specifies the asset type.
   */
  public get AssetType() : string {
    return this._AssetType.value;
  }

  /**
   * ### Asset Code 
   * A unique code that is used to identify the asset. It is generated by hashing the contract public key hash and the asset index. SHA256(contract PKH + asset index)
   */
  public set AssetCode(val: Uint8Array) {
    this._AssetCode = new AssetCode(val);
    this._AssetCode.validate();
  }
  /**
   * ### Asset Code 
   * A unique code that is used to identify the asset. It is generated by hashing the contract public key hash and the asset index. SHA256(contract PKH + asset index)
   */
  public get AssetCode() : Uint8Array {
    return this._AssetCode.value;
  }

  /**
   * ### Proposed Amendments 
   * Each element contains details of which fields to modify, or delete. Because the number of fields in a Contract and Asset is dynamic due to some fields being able to be repeated, the index value of the field needs to be calculated against the Contract or Asset the changes are to apply to. In the event of a Vote being created from this Initiative, the changes will be applied to the version of the Contract or Asset at that time.
   */
  public set ProposedAmendments(val: Amendment[]) {
    this._ProposedAmendments = val;
    this._ProposedAmendments.forEach(i => i.validate());
  }
  /**
   * ### Proposed Amendments 
   * Each element contains details of which fields to modify, or delete. Because the number of fields in a Contract and Asset is dynamic due to some fields being able to be repeated, the index value of the field needs to be calculated against the Contract or Asset the changes are to apply to. In the event of a Vote being created from this Initiative, the changes will be applied to the version of the Contract or Asset at that time.
   */
  public get ProposedAmendments() : Amendment[] {
    return this._ProposedAmendments.map(i => i);
  }

  /**
   * ### Vote Tx ID 
   * Link to the Vote Action txn.
   */
  public set VoteTxId(val: Uint8Array) {
    this._VoteTxId = new TxId(val);
    this._VoteTxId.validate();
  }
  /**
   * ### Vote Tx ID 
   * Link to the Vote Action txn.
   */
  public get VoteTxId() : Uint8Array {
    return this._VoteTxId.value;
  }

  /**
   * ### Option Tally 
   * List of number of valid votes counted for each vote option. Length is encoded like a regular list object, but must match the length of VoteOptions from the Proposal action.
   */
  public set OptionTally(val: number[]) {
    this._OptionTally = val.map(v => new UInt64(v));
    this._OptionTally.forEach(i => i.validate());
  }
  /**
   * ### Option Tally 
   * List of number of valid votes counted for each vote option. Length is encoded like a regular list object, but must match the length of VoteOptions from the Proposal action.
   */
  public get OptionTally() : number[] {
    return this._OptionTally.map(i => i.value);
  }

  /**
   * ### Result 
   * Length 1-255 bytes. 0 is not valid. The Option with the most votes. In the event of a draw for 1st place, all winning options are listed.
   */
  public set Result(val: string) {
    this._Result = new VarChar(val);
    this._Result.validate();
  }
  /**
   * ### Result 
   * Length 1-255 bytes. 0 is not valid. The Option with the most votes. In the event of a draw for 1st place, all winning options are listed.
   */
  public get Result() : string {
    return this._Result.value;
  }

  /**
   * ### Timestamp 
   * Timestamp in nanoseconds of when the smart contract created the action.
   */
  public set Timestamp(val: number) {
    this._Timestamp = new Timestamp(val);
    this._Timestamp.validate();
  }
  /**
   * ### Timestamp 
   * Timestamp in nanoseconds of when the smart contract created the action.
   */
  public get Timestamp() : number {
    return this._Timestamp.value;
  }
}

export default Result;