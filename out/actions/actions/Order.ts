
import BaseType, { FixedChar1, FixedChar3, VarChar, VarBin, UInt8, VarChar_medium } from "./../../Base";
import TargetAddress from "./../../messages/types/TargetAddress";
import QuantityIndex from "./../../actions/types/QuantityIndex";
import ReferenceTransaction from "./../../actions/types/ReferenceTransaction";

/**
 * ### Order ###
 * Used by the administration to signal to the smart contract that the tokens that a particular public address(es) owns are to be confiscated, frozen, thawed or reconciled.
 */
class Order extends BaseType {

  constructor() {
    super();
    super.requiredFieldNames = [  ];
    super.fieldNames = [ "ComplianceAction", "AssetType", "AssetCode", "TargetAddresses", "FreezeTxId", "FreezePeriod", "DepositAddress", "AuthorityName", "AuthorityPublicKey", "SignatureAlgorithm", "OrderSignature", "BitcoinDispersions", "Message", "SupportingEvidenceFormat", "SupportingEvidence", "ReferenceTransactions" ];
  }

  public validate() {
    super.validateAllFields();
  }

  
  private _ComplianceAction: FixedChar1;
  /**
   * # Compliance Action #
   * Freeze (F), Thaw (T), Confiscate (C), Reconcile (R)
   */
  public set ComplianceAction(val: string) {
    this._ComplianceAction = new FixedChar1(val);
    this._ComplianceAction.validate();
  }
  public get ComplianceAction() : string {
    return this._ComplianceAction.value;
  }

  private _AssetType: FixedChar3;
  /**
   * # Asset Type #
   * Three letter character that specifies the asset type.
   */
  public set AssetType(val: string) {
    this._AssetType = new FixedChar3(val);
    this._AssetType.validate();
  }
  public get AssetType() : string {
    return this._AssetType.value;
  }

  private _AssetCode: AssetCode;
  /**
   * # Asset Code #
   * A unique code that is used to identify the asset. It is generated by hashing the contract public key hash and the asset index. SHA256(contract PKH + asset index)
   */
  public set AssetCode(val: AssetCode) {
    this._AssetCode = val;
    this._AssetCode.validate();
  }
  public get AssetCode() : AssetCode {
    // TODO: implement this unsupported scenario
  }

  private _TargetAddresses: TargetAddress[];
  /**
   * # Target Addresses #
   * The holders and quantities that are effected by the order. For a contract or asset wide freeze only the contract address is specified. Zero quantities are invalid unless it is for the contract address in an asset wide or contract wide freeze. In a thaw order this field is not serialized, because the entire freeze from the FreezeTxId freeze action will be thawed.
   */
  public set TargetAddresses(val: TargetAddress[]) {
    this._TargetAddresses = val;
    this._TargetAddresses.forEach(i => i.validate());
  }
  public get TargetAddresses() : TargetAddress[] {
    return this._TargetAddresses;
  }

  private _FreezeTxId: TxId;
  /**
   * # Freeze Tx Id #
   * The tx id of the freeze action that is being thawed. Only serialized for thaw orders.
   */
  public set FreezeTxId(val: TxId) {
    this._FreezeTxId = val;
    this._FreezeTxId.validate();
  }
  public get FreezeTxId() : TxId {
    // TODO: implement this unsupported scenario
  }

  private _FreezePeriod: Timestamp;
  /**
   * # Freeze Period #
   * Used for a 'time out'.  Tokens are automatically unfrozen after the expiration timestamp without requiring a Thaw Action. Null value for Thaw, Confiscation and Reconciallitaion orders.
   */
  public set FreezePeriod(val: Timestamp) {
    this._FreezePeriod = val;
    this._FreezePeriod.validate();
  }
  public get FreezePeriod() : Timestamp {
    // TODO: implement this unsupported scenario
  }

  private _DepositAddress: Address;
  /**
   * # Deposit Address #
   * The public address for confiscated tokens to be deposited in.  Null for Freeze, Thaw, actions.
   */
  public set DepositAddress(val: Address) {
    this._DepositAddress = val;
    this._DepositAddress.validate();
  }
  public get DepositAddress() : Address {
    // TODO: implement this unsupported scenario
  }

  private _AuthorityName: VarChar;
  /**
   * # Authority Name #
   * Length 0-255 bytes. Enforcement Authority Name (eg. Issuer, Queensland Police Service, Tokenized, etc.)
   */
  public set AuthorityName(val: string) {
    this._AuthorityName = new VarChar(val);
    this._AuthorityName.validate();
  }
  public get AuthorityName() : string {
    return this._AuthorityName.value;
  }

  private _AuthorityPublicKey: VarBin;
  /**
   * # Authority Public Key #
   * Length 0-255 bytes. Public Key associated with the Enforcement Authority
   */
  public set AuthorityPublicKey(val: Uint8Array) {
    this._AuthorityPublicKey = new VarBin(val);
    this._AuthorityPublicKey.validate();
  }
  public get AuthorityPublicKey() : Uint8Array {
    return this._AuthorityPublicKey.value;
  }

  private _SignatureAlgorithm: UInt8;
  /**
   * # Signature Algorithm #
   * Algorithm used for order signature. Only valid value is currently 1 = ECDSA+secp256k1
   */
  public set SignatureAlgorithm(val: number) {
    this._SignatureAlgorithm = new UInt8(val);
    this._SignatureAlgorithm.validate();
  }
  public get SignatureAlgorithm() : number {
    return this._SignatureAlgorithm.value;
  }

  private _OrderSignature: VarBin;
  /**
   * # Authority Order Signature #
   * Length 0-255 bytes. Signature for a message that lists out the target addresses and deposit address. Signature of (Contract PKH, Compliance Action, Authority Name, Asset Code, Supporting Evidence Hash, FreezePeriod, TargetAddresses, and DepositAddress)
   */
  public set OrderSignature(val: Uint8Array) {
    this._OrderSignature = new VarBin(val);
    this._OrderSignature.validate();
  }
  public get OrderSignature() : Uint8Array {
    return this._OrderSignature.value;
  }

  private _BitcoinDispersions: QuantityIndex[];
  /**
   * # Bitcoin Dispersions #
   * Index of address in TargetAddresses and amount of bitcoin (in satoshis) they are receiving in exchange for their tokens.
   */
  public set BitcoinDispersions(val: QuantityIndex[]) {
    this._BitcoinDispersions = val;
    this._BitcoinDispersions.forEach(i => i.validate());
  }
  public get BitcoinDispersions() : QuantityIndex[] {
    return this._BitcoinDispersions;
  }

  private _Message: VarChar_medium;
  /**
   * # Message #
   * A message to include with the enforcement order.
   */
  public set Message(val: string) {
    this._Message = new VarChar_medium(val);
    this._Message.validate();
  }
  public get Message() : string {
    return this._Message.value;
  }

  private _SupportingEvidenceFormat: UInt8;
  /**
   * # Supporting Evidence Format #
   * The data format of the supporting evidence field. 0 = no evidence data provided, 1 = markdown containing warrant, court order, etc.
   */
  public set SupportingEvidenceFormat(val: number) {
    this._SupportingEvidenceFormat = new UInt8(val);
    this._SupportingEvidenceFormat.validate();
  }
  public get SupportingEvidenceFormat() : number {
    return this._SupportingEvidenceFormat.value;
  }

  private _SupportingEvidence: VarBin;
  /**
   * # Supporting Evidence #
   * Supporting evidence related to the order being requested.
   */
  public set SupportingEvidence(val: Uint8Array) {
    this._SupportingEvidence = new VarBin(val);
    this._SupportingEvidence.validate();
  }
  public get SupportingEvidence() : Uint8Array {
    return this._SupportingEvidence.value;
  }

  private _ReferenceTransactions: ReferenceTransaction[];
  /**
   * # Reference Transactions #
   * The request/response actions that were dropped.  The entire txn for both actions is included as evidence that the actions were accepted into the mempool at one point and that the senders (token/Bitcoin) signed their intent to transfer.  The management of this record keeping is off-chain and managed by the administration or operator to preserve the integrity of the state of the tokens. Only applicable for reconcilliation actions.  No subfield when F, T, R is selected as the Compliance Action subfield.
   */
  public set ReferenceTransactions(val: ReferenceTransaction[]) {
    this._ReferenceTransactions = val;
    this._ReferenceTransactions.forEach(i => i.validate());
  }
  public get ReferenceTransactions() : ReferenceTransaction[] {
    return this._ReferenceTransactions;
  }
}

export default Order;