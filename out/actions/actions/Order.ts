
import BaseType, { FixedChar1, FixedChar3, AssetCode, TxId, Timestamp, Address, VarChar, VarBin, UInt8, VarChar_medium } from "./../../Base";
import TargetAddress from "./../../messages/types/TargetAddress";
import QuantityIndex from "./../../actions/types/QuantityIndex";
import ReferenceTransaction from "./../../actions/types/ReferenceTransaction";

/**
 * # Order
 * Used by the administration to signal to the smart contract that the tokens that a particular public address(es) owns are to be confiscated, frozen, thawed or reconciled.
 */
class Order extends BaseType {

  constructor() {
    super();
    super.requiredFieldNames = [  ];
    super.fieldNames = [ "ComplianceAction", "AssetType", "AssetCode", "TargetAddresses", "FreezeTxId", "FreezePeriod", "DepositAddress", "AuthorityName", "AuthorityPublicKey", "SignatureAlgorithm", "OrderSignature", "BitcoinDispersions", "Message", "SupportingEvidenceFormat", "SupportingEvidence", "ReferenceTransactions" ];
  }

  public validate() {
    super.validateAllFields();
  }

  
/** ## COMPLIANCE ACTION */
  private _ComplianceAction: FixedChar1;
  /**
   * ### Compliance Action 
   * Freeze (F), Thaw (T), Confiscate (C), Reconcile (R)
   */
  public set ComplianceAction(val: string) {
    this._ComplianceAction = new FixedChar1(val);
    this._ComplianceAction.validate();
  }
  /**
   * ### Compliance Action 
   * Freeze (F), Thaw (T), Confiscate (C), Reconcile (R)
   */
  public get ComplianceAction() : string {
    return this._ComplianceAction.value;
  }

/** ## ASSET TYPE */
  private _AssetType: FixedChar3;
  /**
   * ### Asset Type 
   * Three letter character that specifies the asset type.
   */
  public set AssetType(val: string) {
    this._AssetType = new FixedChar3(val);
    this._AssetType.validate();
  }
  /**
   * ### Asset Type 
   * Three letter character that specifies the asset type.
   */
  public get AssetType() : string {
    return this._AssetType.value;
  }

/** ## ASSET CODE */
  private _AssetCode: AssetCode;
  /**
   * ### Asset Code 
   * A unique code that is used to identify the asset. It is generated by hashing the contract public key hash and the asset index. SHA256(contract PKH + asset index)
   */
  public set AssetCode(val: Uint8Array) {
    this._AssetCode = new AssetCode(val);
    this._AssetCode.validate();
  }
  /**
   * ### Asset Code 
   * A unique code that is used to identify the asset. It is generated by hashing the contract public key hash and the asset index. SHA256(contract PKH + asset index)
   */
  public get AssetCode() : Uint8Array {
    return this._AssetCode.value;
  }

/** ## TARGET ADDRESSES */
  private _TargetAddresses: TargetAddress[];
  /**
   * ### Target Addresses 
   * The holders and quantities that are effected by the order. For a contract or asset wide freeze only the contract address is specified. Zero quantities are invalid unless it is for the contract address in an asset wide or contract wide freeze. In a thaw order this field is not serialized, because the entire freeze from the FreezeTxId freeze action will be thawed.
   */
  public set TargetAddresses(val: TargetAddress[]) {
    this._TargetAddresses = val;
    this._TargetAddresses.forEach(i => i.validate());
  }
  /**
   * ### Target Addresses 
   * The holders and quantities that are effected by the order. For a contract or asset wide freeze only the contract address is specified. Zero quantities are invalid unless it is for the contract address in an asset wide or contract wide freeze. In a thaw order this field is not serialized, because the entire freeze from the FreezeTxId freeze action will be thawed.
   */
  public get TargetAddresses() : TargetAddress[] {
    return this._TargetAddresses;
  }

/** ## FREEZE TX ID */
  private _FreezeTxId: TxId;
  /**
   * ### Freeze Tx Id 
   * The tx id of the freeze action that is being thawed. Only serialized for thaw orders.
   */
  public set FreezeTxId(val: Uint8Array) {
    this._FreezeTxId = new TxId(val);
    this._FreezeTxId.validate();
  }
  /**
   * ### Freeze Tx Id 
   * The tx id of the freeze action that is being thawed. Only serialized for thaw orders.
   */
  public get FreezeTxId() : Uint8Array {
    return this._FreezeTxId.value;
  }

/** ## FREEZE PERIOD */
  private _FreezePeriod: Timestamp;
  /**
   * ### Freeze Period 
   * Used for a 'time out'.  Tokens are automatically unfrozen after the expiration timestamp without requiring a Thaw Action. Null value for Thaw, Confiscation and Reconciallitaion orders.
   */
  public set FreezePeriod(val: number) {
    this._FreezePeriod = new Timestamp(val);
    this._FreezePeriod.validate();
  }
  /**
   * ### Freeze Period 
   * Used for a 'time out'.  Tokens are automatically unfrozen after the expiration timestamp without requiring a Thaw Action. Null value for Thaw, Confiscation and Reconciallitaion orders.
   */
  public get FreezePeriod() : number {
    return this._FreezePeriod.value;
  }

/** ## DEPOSIT ADDRESS */
  private _DepositAddress: Address;
  /**
   * ### Deposit Address 
   * The public address for confiscated tokens to be deposited in.  Null for Freeze, Thaw, actions.
   */
  public set DepositAddress(val: Uint8Array) {
    this._DepositAddress = new Address(val);
    this._DepositAddress.validate();
  }
  /**
   * ### Deposit Address 
   * The public address for confiscated tokens to be deposited in.  Null for Freeze, Thaw, actions.
   */
  public get DepositAddress() : Uint8Array {
    return this._DepositAddress.value;
  }

/** ## AUTHORITY NAME */
  private _AuthorityName: VarChar;
  /**
   * ### Authority Name 
   * Length 0-255 bytes. Enforcement Authority Name (eg. Issuer, Queensland Police Service, Tokenized, etc.)
   */
  public set AuthorityName(val: string) {
    this._AuthorityName = new VarChar(val);
    this._AuthorityName.validate();
  }
  /**
   * ### Authority Name 
   * Length 0-255 bytes. Enforcement Authority Name (eg. Issuer, Queensland Police Service, Tokenized, etc.)
   */
  public get AuthorityName() : string {
    return this._AuthorityName.value;
  }

/** ## AUTHORITY PUBLIC KEY */
  private _AuthorityPublicKey: VarBin;
  /**
   * ### Authority Public Key 
   * Length 0-255 bytes. Public Key associated with the Enforcement Authority
   */
  public set AuthorityPublicKey(val: Uint8Array) {
    this._AuthorityPublicKey = new VarBin(val);
    this._AuthorityPublicKey.validate();
  }
  /**
   * ### Authority Public Key 
   * Length 0-255 bytes. Public Key associated with the Enforcement Authority
   */
  public get AuthorityPublicKey() : Uint8Array {
    return this._AuthorityPublicKey.value;
  }

/** ## SIGNATURE ALGORITHM */
  private _SignatureAlgorithm: UInt8;
  /**
   * ### Signature Algorithm 
   * Algorithm used for order signature. Only valid value is currently 1 = ECDSA+secp256k1
   */
  public set SignatureAlgorithm(val: number) {
    this._SignatureAlgorithm = new UInt8(val);
    this._SignatureAlgorithm.validate();
  }
  /**
   * ### Signature Algorithm 
   * Algorithm used for order signature. Only valid value is currently 1 = ECDSA+secp256k1
   */
  public get SignatureAlgorithm() : number {
    return this._SignatureAlgorithm.value;
  }

/** ## AUTHORITY ORDER SIGNATURE */
  private _OrderSignature: VarBin;
  /**
   * ### Authority Order Signature 
   * Length 0-255 bytes. Signature for a message that lists out the target addresses and deposit address. Signature of (Contract PKH, Compliance Action, Authority Name, Asset Code, Supporting Evidence Hash, FreezePeriod, TargetAddresses, and DepositAddress)
   */
  public set OrderSignature(val: Uint8Array) {
    this._OrderSignature = new VarBin(val);
    this._OrderSignature.validate();
  }
  /**
   * ### Authority Order Signature 
   * Length 0-255 bytes. Signature for a message that lists out the target addresses and deposit address. Signature of (Contract PKH, Compliance Action, Authority Name, Asset Code, Supporting Evidence Hash, FreezePeriod, TargetAddresses, and DepositAddress)
   */
  public get OrderSignature() : Uint8Array {
    return this._OrderSignature.value;
  }

/** ## BITCOIN DISPERSIONS */
  private _BitcoinDispersions: QuantityIndex[];
  /**
   * ### Bitcoin Dispersions 
   * Index of address in TargetAddresses and amount of bitcoin (in satoshis) they are receiving in exchange for their tokens.
   */
  public set BitcoinDispersions(val: QuantityIndex[]) {
    this._BitcoinDispersions = val;
    this._BitcoinDispersions.forEach(i => i.validate());
  }
  /**
   * ### Bitcoin Dispersions 
   * Index of address in TargetAddresses and amount of bitcoin (in satoshis) they are receiving in exchange for their tokens.
   */
  public get BitcoinDispersions() : QuantityIndex[] {
    return this._BitcoinDispersions;
  }

/** ## MESSAGE */
  private _Message: VarChar_medium;
  /**
   * ### Message 
   * A message to include with the enforcement order.
   */
  public set Message(val: string) {
    this._Message = new VarChar_medium(val);
    this._Message.validate();
  }
  /**
   * ### Message 
   * A message to include with the enforcement order.
   */
  public get Message() : string {
    return this._Message.value;
  }

/** ## SUPPORTING EVIDENCE FORMAT */
  private _SupportingEvidenceFormat: UInt8;
  /**
   * ### Supporting Evidence Format 
   * The data format of the supporting evidence field. 0 = no evidence data provided, 1 = markdown containing warrant, court order, etc.
   */
  public set SupportingEvidenceFormat(val: number) {
    this._SupportingEvidenceFormat = new UInt8(val);
    this._SupportingEvidenceFormat.validate();
  }
  /**
   * ### Supporting Evidence Format 
   * The data format of the supporting evidence field. 0 = no evidence data provided, 1 = markdown containing warrant, court order, etc.
   */
  public get SupportingEvidenceFormat() : number {
    return this._SupportingEvidenceFormat.value;
  }

/** ## SUPPORTING EVIDENCE */
  private _SupportingEvidence: VarBin;
  /**
   * ### Supporting Evidence 
   * Supporting evidence related to the order being requested.
   */
  public set SupportingEvidence(val: Uint8Array) {
    this._SupportingEvidence = new VarBin(val);
    this._SupportingEvidence.validate();
  }
  /**
   * ### Supporting Evidence 
   * Supporting evidence related to the order being requested.
   */
  public get SupportingEvidence() : Uint8Array {
    return this._SupportingEvidence.value;
  }

/** ## REFERENCE TRANSACTIONS */
  private _ReferenceTransactions: ReferenceTransaction[];
  /**
   * ### Reference Transactions 
   * The request/response actions that were dropped.  The entire txn for both actions is included as evidence that the actions were accepted into the mempool at one point and that the senders (token/Bitcoin) signed their intent to transfer.  The management of this record keeping is off-chain and managed by the administration or operator to preserve the integrity of the state of the tokens. Only applicable for reconcilliation actions.  No subfield when F, T, R is selected as the Compliance Action subfield.
   */
  public set ReferenceTransactions(val: ReferenceTransaction[]) {
    this._ReferenceTransactions = val;
    this._ReferenceTransactions.forEach(i => i.validate());
  }
  /**
   * ### Reference Transactions 
   * The request/response actions that were dropped.  The entire txn for both actions is included as evidence that the actions were accepted into the mempool at one point and that the senders (token/Bitcoin) signed their intent to transfer.  The management of this record keeping is off-chain and managed by the administration or operator to preserve the integrity of the state of the tokens. Only applicable for reconcilliation actions.  No subfield when F, T, R is selected as the Compliance Action subfield.
   */
  public get ReferenceTransactions() : ReferenceTransaction[] {
    return this._ReferenceTransactions;
  }
}

export default Order;